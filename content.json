{"pages":[],"posts":[{"title":"","text":"代理模式代理设计模式：为其他对象提供一种代理，以控制对这个对象的访问。使用代理模式创建代理对象，让代理对象控制目标对象的访问，并且可以在不改变目标对象的情况下，添加一些额外的功能。还隐藏被代理类的细节。 静态代理UML类图： 被代理的类123456789101112131415/** * 目标类，潘** */public class PJL implements Methods { /** * 被代理的方法 */ @Override public void he() { System.out.println(&quot;羞羞羞&quot;); } public void eat(){ System.out.println(&quot;吃饭饭&quot;); }} 代理接口:123456789/** * 代理接口 */public interface Methods { /** * 羞羞的方法 */ public void he();} 代理类：123456789101112/** * 代理者，王* */public class WP implements Methods { private Methods methods ; @Override public void he() { methods = new PJL(); System.out.println(&quot;给点小费呗&quot;); methods.he(); }} 测试类：123456789/** * 测试类，西门* */public class XMQ { public static void main(String[] args) { WP wp = new WP(); wp.he(); }} 水浒传中这件是算是比较典型的代理模式了，西门去找潘**，二人又不是夫妻，某些事情上西门不能直接去找潘 ，所以就找代理者王婆，让王婆代替自己去找潘 ，然后在某个地方碰面。本来西门直接去找潘 ，潘 是不会收钱的，但是王婆觉得我既然都帮你做这种事了自然要收点小费，小费的收取属于王婆，而不属于潘 *，这也就是额外的代码功能。 动态代理动态代理类在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和被代理类的关系是在程序运行时确定。 被代理的类：1234567891011121314151617181920212223package moving;/** * 目标类 * @author asus */public class lucida implements lucidaMethod{ @Override public String show(String name) { System.out.println(&quot;跳了一支《&quot;+name+&quot;》舞&quot;); return &quot;跳完了&quot;; } @Override public String sing(String name) { System.out.println(&quot;唱了一首《&quot;+name+&quot;》&quot;); return &quot;唱完啦&quot;; } /** *此方法不需要被代理，不需要抽成接口 */ public void eat(){ System.out.println(&quot;吃饭&quot;); }} 代理接口中需要被代理的方法的接口：1234567891011121314151617181920package moving;/** * 需要被代理的方法 * @author asus * */public interface lucidaMethod { /** * 跳舞 * @param name 舞蹈名字 * @return 是否表演 */ public String show(String name); /** * 唱歌 * @param name 歌曲名字 * @return 是否唱歌 */ public String sing(String name);} 代理类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package moving;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * 代理类 * @author asus * */public class ProxyClass { /**创建被代理的对象，*/ private static final lucida lu = new lucida(); /** * 访问代理类的方法 * @return 被代理的方法 */ public static lucidaMethod getPoxyInstance(){ //使用proxy中的方法获取代理类对象 lucidaMethod obj = (lucidaMethod)Proxy.newProxyInstance( //第一个参数，定义代理类的类加载器 ProxyClass.class.getClassLoader(), //第二个参数，代理类要实现的接口列表 lu.getClass().getInterfaces(), /* *第三个参数 * 拦截外界调用代理对象中的任何方法， * 当外界调用代理对象的的方法后，InvocationHandler类中的invoke方法自动执行 */ new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //对show方法进行增强 if(&quot;show&quot;.equals(method.getName())){ System.out.println(&quot;先给钱，跳舞&quot;); return method.invoke(lu, args); //对sing方法进行增强 }else if(&quot;sing&quot;.equals(method.getName())){ System.out.println(&quot;先给钱，然后才可以唱歌&quot;); return method.invoke(lu, args); }else{ System.out.println(&quot;暂时没有代理此业务&quot;); } return null; } }); return obj; }} 结语：未完待续吧，等领悟的更加透彻后，再做修改。","link":"/2019/06/20/代理模式/"},{"title":"为什么程序员都应该使用MarkDown","text":"一.MrakDown简介&emsp;&emsp;Mrakdown：一种轻量级标记语言，语法简洁明了，易于掌握，易读易写。MrakDown如今被程序员广泛使用，适用于写博客日志、技术文稿、记录代码片段、起草邮件等场景。 &emsp;Mrakdown的优点： 可以使我专注于文字的内容，而非排版样式 能够轻松的导出HTML、PDF以及.md文件 纯文本内容，兼容所有的文本编辑器与字处理软件 可读、直观、学习成本低&emsp;Markdown的缺点： 格式单一，不支持类似于word一样的负责的格式 对图片等其他资源的排版不具备个性化处理功能二.MarkDown常用语法1.标题markdown中共包含6级标题,字体大小递减123456# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题 2.标题字体样式12345*内容* 斜体**内容** 加粗***内容*** 斜体加粗~~内容~~ 删除线&lt;font face=&quot;宋体&quot; color:&quot;black&quot; size=&quot;6&quot;&gt;字体大小样式和颜色&lt;/font&gt; 3.列表3.1 无序列表无序列表使用-、+和*作为列表标记12345678- 条目1- 条目2+ 条目1+ 条目2* 条目1* 条目2 3.2 有序列表有序列表使用数字加英文句点表示； 4.引用123&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用 5.字体上下标12&lt;sup&gt;这是上标&lt;/sup&gt;&lt;sub&gt;这是下标&lt;/sub&gt; 6.图片和链接&emsp;&emsp;图片和链接的语法很像，区别在一个！号，需要注意的是，markdown不能设置图片的大小，如果要设置，则使用标签.12图片：！[图片描述（可忽略）](链接的地址)链接：[链接描述]（链接的地址） 链接分为行内式、参考式和自动链接1234行内式：[链接文本]（http://www.google.com）参考式：[链接文本][url],其中url为链接标记，可置于文本中任意位置 [url]:www.google.com自动链接：&lt;www.google.com&gt; 7.代码块1&lt;h4&gt;以```开始和结尾，中间可以书写任意格式的代码&lt;/h4&gt; 8.表格123|姓名|年龄|班级||:---|:---|:---||左对齐|居中对齐|右对齐| 示例：|姓名|年龄|班级||:—|:—|:—||左对齐|居中对齐|右对齐| 9.分割线12345***---————* * *上述四种写法均表示分割线 10.脚注|注解10.1使用[^]来定义脚注：12示例：[^1][^1]:脚注 10.2注释注释仅自己可见，无预览效果1&lt;!--注释--&gt;","link":"/2019/04/03/MarkDown/"},{"title":"浅谈sql优化","text":"&emsp;&emsp;数据库查询效率的快慢是评价一个数据库设计好坏的直接判定依据，一个设计良好的数据库系统，受到多方面的因素影响，例如硬件配置、网络状况等。对于程序设计人员，提高数据库查询效率最有效的最简单的方式便是优化sql语句；&emsp;&emsp;造成数据库查询缓慢的常见原因：&emsp;&emsp;&emsp;&emsp;1.查询数据的数据量庞大；&emsp;&emsp;&emsp;&emsp;2.数据库设计不合理；&emsp;&emsp;&emsp;&emsp;3.sql语句书写不佳；&emsp;&emsp;&emsp;&emsp;4.硬件性能、网络状况；&emsp;&emsp;&emsp;&emsp;……&emsp;&emsp;正是由于上述存在的问题，优化数据库应该从数据库设计、sql语句书写入手，从源头进行优化，尽量避免进行全表扫描，正确合理的使用索引，本系列文章将和大家共同探讨sql的优化； 一.了解数据库表&emsp;1.巧用explain:explain命令可以查看sql的执行计划，执行状态，例如是否使用索引，是否全表查询，也可以使用explain查看数据表的设计详情；&emsp;2.在select前加上explain命令可以显示数据库执行的具体情况二.巧用索引&emsp;&emsp;要想让一个查询语句执行效率更快。首要的，需要考虑能否添加索引。索引是一个特殊的文件，包含着对数据库表中所有记录的指针，它是对数据库表中一列或者多列的值进行排序的一种结构。&emsp;&emsp;索引好比是图书馆里，每一本书上的编号，借阅者可以通过图书馆的馆藏搜索系统，快速的查找到对应的书籍的所在位置，大大减少了寻找的时间，提供搜索效率；&emsp;&emsp;索引的优点:&emsp;&emsp;&emsp;&emsp;1.通过添加唯一索引，可以保证数据唯一性；&emsp;&emsp;&emsp;&emsp;2.可以大大提高数据的检索速度；&emsp;&emsp;&emsp;&emsp;3.可以加速表和表之间的连接；&emsp;&emsp;索引大体可以分为：普通索引、唯一索引、主键索引、全文索引12345678910普通索引分为单列索引和多列索引：1.单列索引：一个索引只包含单个列，但是一个表中可以包含多个单列索引；2.多列索引：一个索引包含多个索引；创建普通索引：- create index 索引名 on 表名（列名）- alter table 表名 add unique index 索引名（列名）- create table 表名 （ 列名 数据类型 约束， unique index 索引名（列名） ）","link":"/2019/04/08/浅谈sql优化/"},{"title":"","text":"初识索引和视图视图关键字：view视图在数据库管理系统中也是一个对象，以文件形式存在视图对应一个查询结果，只是从不同的角度看数据语法：create view 视图名字 as 查询语句; 索引一种特殊的文件，它包含着对数据库表所有记录的引用指针，它是对数据库中一列或者多列的值进行排序的一种结构。优点：1、创建唯一索引，保证数据库中每一条数据的唯一性（实体完整性）2、加快数据的检索速度。3、加速表与表之间的连接。4、使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序时间。5、通过使用索引，可以在查询的过程中，使用优化器，提高系统的性能。普通索引基本索引，没有任何限制，索引分为单列索引和多列索引。语法： 创建：create index 索引名 on 表名(表中的列名) 添加：alter table 表名 add index 索引名(列名)创建表时添加索引：1234create table 表名（列名 列的数据类型 列的约束，index 索引名（列名）） 唯一索引、关键字 ：unique index它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。主键索引它是一种特殊的唯一索引，不允许有空值，在创建主键时，会默认生成一个主键索引。全文索引现在的互联网上，很多网站都提供了全文搜索(全文检索)功能，浏览者可以通过输入关键字或者是短语来搜索特定的资料。通常的做法是通过 select 查询的 like 语句来进行搜索，这一办法存在搜索不够精确、以及效率非常低下的缺点。mysql 提供了一个全文索引功能，也就是把字段设置上fullText索引属性，然后通过select的match against语句进行查找。mysql 支持全文索引和搜索功能，但是 fullText 索引仅能用于 myisam 引擎的表。myisam 引擎支持全文检索（full text index），查询效率高。但是有局限，不支持事务和外键。语法：1234561.Create fulltext index 索引名 on 表名（表中加索引的列）2.alter table 表名 add fulltext index 索引名(表中加索引的列)3. create table 表名（ 列名 列的数据类型 列的约束， fulltext 索引名（表中加索引的列） ） 存储引擎存储引擎是MySQL特有的。存储引擎的本质：1、采用不同的技术想暑假存储在文件或者内存中。2、每一种技术都有不同的储存机制，不同的存储机制提供不同的功能和能力。3、通过选择不同的技术（不同的引擎），可以获得额外的速度或者功能，改善我们的应用。 查看储存引擎：show engines\\G创建表时，显示的指定引擎：create table 表名()engine=引擎名称默认引擎的修改：在my.ini配置文件中使用default-storage-engin选项指定修改表的引擎：alter table 表名 engine = 引擎名称 常用的储存引擎：12345678910111213141516171819202122232425262728MylSAM存储引擎 特性： 一、使用三个文件表示每个表： 1.格式文件—存储表的结构（mytable.frm） 2.数据文件—存储表的数据（mytable.MYD） 3.索引文件—存储表的索引（mytable.MYI） 二、可以压缩空间，节省内存。 InnoDB存储引擎（默认引擎）特性： 1.每个InnoDB表在数据库目录中以.frm格式文件表示。 2.InnoDB表空间tablespace被用于存储表的内容。 3.提供一组用来记录事物性活动的日志文件 4.用COMMIT(提交)、SAVEPOINT及ROLLBACK（回滚） 支持事物处理。 5.提供全部ACID兼容。 6.在MySQL服务器崩溃后提供自动恢复。 7.多版本（MVCC）和行级锁定。 8.支持外键以及引用的完整性，包括级联更新和删除。 MEMORY存储引擎使用MEMORY存储引擎的表，因为数据存储在内存中，且行的长度固定，所以使得MEMORY存储引擎非常快。特点： 1.在数据库目录内，每个表均以.frm格式文件表示。 2.表数据及索引被存储在内存中。 3.表级锁机制。 4.字段属性不能包含TEXT或BLOB字段。 MEMORY存储引擎以前被称为HEAP引擎 不同引擎的适用场景：1、MyISAM存储引擎的表适合于大量的数据读而少量的数据更新的混合操作，MyISAMB表的另一种使用形式是使用压缩的只读表。2、InnoDB存储引擎的表使用于含较多的数据更新操作，其行级锁机制和多版本的支持为数据读取和更新额混合提供了良好的并发机制。3.MEMORY存储引擎存储费永久需要的数据，或者能够从基于磁盘的表中重新生成的数据","link":"/2019/06/20/索引和视图/"},{"title":"","text":"初始装饰者模式定义：动态地给一个对象添加一些额外的职责。也就是扩展功能，装饰者模式相对于继承产生子类更加灵活，便于代码的复用，就像彩虹（被装饰者），彩虹由好几种颜色（装饰者）组成，颜色可以随意排列、添加。重点：装饰者与被装饰者拥有共同的基类，继承的目的是继承类型，而不是行为。 代码实现：123456/** * 被装饰者 */public interface Eat { public abstract void eat();} 装饰者12345678910111213141516/** * 装饰者 * @author asus * */public abstract class AEat implements Eat{ private Eat eat; public AEat(Eat eat) { this.eat=eat; } @Override public void eat() { eat.eat(); }} 对装饰者AEat的一个细化1234567891011121314151617181920212223242526272829303132333435363738/** * 装饰者 */public class BEat extends AEat{ public BEat(Eat eat) { super(eat); } @Override public void eat() { super.eat(); System.out.println(&quot;加点醋！&quot;); }/** * 装饰者 */public class CEat extends AEat { public CEat(Eat eat) { super(eat); } @Override public void eat() { super.eat();; System.out.println(&quot;多放辣椒&quot;); }}/** * 装饰者 */public class DEat extends AEat{ public DEat(Eat eat) { super(eat); } @Override public void eat() { super.eat();; System.out.println(&quot;今天吃鸡&quot;); } } 123456789/** * 被装饰者的实现类，本身就有方式的实现 */public class TsetEat implements Eat{ @Override public void eat() { System.out.println(&quot;我今天吃什么呢？&quot;); }} 12345678910111213/** * 测试 */public class Test { public static void main(String[] args) { //创建了一个吃的类，但是不满意现有的行为，还要对这个吃类进行装饰 Eat eat = new TsetEat(); //对eat的装饰，可以随意组合装饰者，执行的结果也将不一样。 Eat e = new CEat(new BEat(new DEat(eat))); e.eat(); }} 执行结果：","link":"/2019/06/20/装饰者模式/"},{"title":"","text":"MyBatis plus使用手册前言&emsp;&emsp;mybatis plus(后简称MP)，是对mybatis的一个增强工具，使用MP不影响mybatis的基本使用，使用与JPA类似，目的为简化开发，提升效率。 一.安装&emsp;&emsp;使用spring boot 集成，只需要在pom.xml中加入MP的依赖包，需要注意的是，引入MP时不需要再引入mybatis，以免引起版本冲突123456&lt;!--引入mybatis plus 依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 二.配置&emsp;&emsp;MP提供了很多的配置选项，这里我们只配置基础配置，更多配置及进阶配置，可以查看官网手册&emsp;mybatis plus官网在springboot中，配置书写在application.properties中123456789&lt;!--配置数据源--&gt;spring.datasource.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=tt123456&lt;!--配置别名--&gt;mybatis-plus.type-aliases-package=com.lovo.entity&lt;!--配置sql语句控制台输出--&gt;mybatis-plus.configuration.log-impl= org.apache.ibatis.logging.stdout.StdOutImpl &emsp;&emsp;在MP中内置了分页插件，需要通过java类的方式进行配置，可以在工程下建一个config的包，再建一个MybatisPlusConfig配置文件,该文件直接复制即可，不做更改123456789101112@Configurationpublic class MybatisPlusConfig { /** * mybatis-plus分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor page = new PaginationInterceptor(); page.setDialectType(&quot;mysql&quot;); return page; }} 三.基础使用&emsp;&emsp;MP内置了基本的CRUD，条件查询，分页等操作，可以极大简化单表操作效率；&emsp;&emsp;首先，MP中提供了代码生成器功能，可以直接使用该工具生成mapper,controller,Entity,Service类，但生成的类仅有类名和一些继承关系，感觉用处不是很大，并且生成的诸如实体类，由于MP自己的映射关系，生成的字段不便于阅读，故建议不采用此功能&emsp;&emsp;然后，MP中提供了两类CRUD接口，一类是Mapper接口，一类是service接口，两者功能相似，service接口实则是对mapper接口方法的调用和封装，因此，本文只介绍mapper接口使用方法，service接口方法可自行查阅官网文档；&emsp;&emsp;Mapper接口方法的使用仅需要集成BaseMapper接口，就可以使用MP为我们提供的方法；1public interface UserMapper extends SqlMapper, BaseMapper&lt;UserEntity&gt; 1.常用注解12345678@TableName(&quot;t_user&quot;) // 用于表示实体类对应的数据库表名public class UserEntity @TableId // 主键标识private int id; @TableField(&quot;username&quot;) // 当属性名和数据库字段名不匹配时用于表示对应关系private String name; 2.条件构造器Warpper&emsp;&emsp;MP种支持单字段,List集合，Map集合，条件构造器作为条件的CRUD操作，其中前三者较为常见，而条件构造器接触较少，故单独做一介绍；条件构造器包含QueryWarpper和UpdateWarpper，两者功能基本一致，提供eq(等于)、ne(不等于)、gt(大于)、lt（小于）、like、notlike、in、ordreBy等大量的条件判断方法； -addEq:多个字段对应相等；12allEq(Map&lt;R, V&gt; params)allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt; 0,{id:1,name:&quot;老王&quot;,age:null})---&gt;name = &apos;老王&apos; and age is null -eq:相等；12eq(R column, Object val)eq(&quot;name&quot;, &quot;老王&quot;)---&gt;name = &apos;老王&apos; -ne:不相等；12ne(R column, Object val)ne(&quot;name&quot;, &quot;老王&quot;)---&gt;name &lt;&gt; &apos;老王&apos; -gt:大于；12gt(R column, Object val)gt(&quot;age&quot;, 18)---&gt;age &gt; 18 -ge:大于等于；12ge(R column, Object val)ge(&quot;age&quot;, 18)---&gt;age &gt;= 18 -lt:小于；12lt(R column, Object val)lt(&quot;age&quot;, 18)---&gt;age &lt; 18 -le:小于等于；12le(R column, Object val)le(&quot;age&quot;, 18)---&gt;age &lt;= 18 -between:BETWEEN 值1 AND 值2；12between(R column, Object val1, Object val2)between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30 -notBetween:NOT BETWEEN 值1 AND 值212notBetween(R column, Object val1, Object val2)notBetween(&quot;age&quot;, 18, 30)---&gt;age not between 18 and 30 -like:LIKE ‘%值%’12like(R column, Object val)like(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王%&apos; -notlike：NOT LIKE ‘%值%’12notLike(R column, Object val)notLike(&quot;name&quot;, &quot;王&quot;)---&gt;name not like &apos;%王%&apos; -likeLeft ：LIKE ‘%值’12likeLeft(R column, Object val)likeLeft(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王&apos; -likeRight:LIKE ‘值%’12likeRight(R column, Object val)likeRight(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;王%&apos; -isNull:字段 IS NULL12isNull(R column)isNull(boolean condition, R column) -isNotNull:字段 IS NOT NULL12isNotNull(R column)isNotNull(&quot;name&quot;)---&gt;name is not null -in:字段 IN (value.get(0), value.get(1), …)12in(R column, Collection&lt;?&gt; value)in(&quot;age&quot;,{1,2,3})---&gt;age in (1,2,3) -notIn:字段 notIn (value.get(0), value.get(1), …)12notIn(R column, Collection&lt;?&gt; value)notIn(&quot;age&quot;,{1,2,3})---&gt;age not in (1,2,3) -inSql:字段 IN ( sql语句 )12inSql(R column, String inValue)inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3) -notInSql:NOT IN ( sql语句 )12notInSql(R column, String inValue)notInSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;age not in (select id from table where id &lt; 3) -groupBy:GROUP BY 字段, …12groupBy(R... columns)groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name -orderByAsc:ORDER BY 字段, … ASC12orderByAsc(R... columns)orderByAsc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id ASC,name ASC -orderByDesc:ORDER BY 字段, … DESC12orderByDesc(R... columns)orderByDesc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id DESC,name DESC 注：上述条件方法均含有一个默认值为true的参数，表示该条件会拼接到SQL语句中，如传一个false,则该条件不会拼接到SQL中，在动态条件查询时，可以传入StringUtils.isNotEmpty(参数)来动态拼接sql语句；更多条件方法可上官网了解详情 -创建条件构造器1234&lt;!--直接new对象--&gt;QueryWrapper&lt;T&gt; wrapper = new QueryWrapper&lt;&gt;();&lt;!--使用Warppers工具类获得--&gt;QueryWrapper&lt;T&gt; wrapper = Warppers.&lt;T&gt;query(); -使用实例12345678&lt;!--查询姓张，年龄20-40岁之间且邮箱不为空的记录，查询字段不包括密码--&gt;QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;) .between(&quot;age&quot;,20,40) .isNotNull(&quot;email&quot;) .select(UserEntity.class,query-&gt;!query.getColumn().equals(&quot;password&quot;));List&lt;UserEntity&gt; users = userDao.selectList(wrapper);users.forEach(System.out::println); 3.添加- int insert(T entity)&emsp;&emsp;传入对象即可完成添加，返回操作条数 4.删除- int deleteById(Serializable id)&emsp;&emsp;通过id进行删除，返回操作条数 - int deleteByMap(Map&lt;String, Object&gt; columnMap)&emsp;&emsp;通过Map集合进行删除，返回操作条数，map集合为键为表的字段，值为字段所对应的值，后面所有Map用法相同，不做赘述；12345&lt;!--相当于delete from t_user where username=&apos;musi&apos; and age=26--&gt;Map &lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;username&quot;,&quot;musi&quot;);map.put(&quot;age&quot;,26);int result = userDao.deleteByMap(map); -int delete( Wrapper wrapper)&emsp;&emsp;通过条件构造器进行删除123QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.inSql(&quot;age&quot;,&quot;35,25&quot;);int result = userDao.delete(wrapper); -int deleteBatchIds( Collection&lt;? extends Serializable&gt; idList)&emsp;&emsp;通过id集合批量删除;12List&lt;Integer&gt; ids = Arrays.asList(13,12);int result = userDao.deleteBatchIds(ids); 5.修改-int updateById(T t)&emsp;&emsp;传入修改对象实例 -int update( T t,Wrapper updateWrapper);&emsp;&emsp;根据条件构造器修改123456UserEntity user = userDao.selectById(2);user.setName(&quot;田七&quot;);user.setAge(30);UpdateWrapper&lt;UserEntity&gt; update = new UpdateWrapper&lt;&gt;();update.eq(&quot;age&quot;,20).eq(&quot;username&quot;,&quot;赵六&quot;);int result= userDao.update(user,update); 6.查询- T selectById(Serializable id)&emsp;&emsp;根据id查询单个对象 -List selectBatchIds(Collection&lt;? extends Serializable&gt; idList);&emsp;&emsp;通过id集合查询对象集合 -List selectByMap(Map&lt;String, Object&gt; columnMap);&emsp;&emsp;根据map集合查询对象集合，用法与前文map集合用法相同 -UserEntity selectOne( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询单个对象，用法与前文条件构造器用法相同 - Integer selectCount(Wrapper queryWrapper);&emsp;&emsp;条件构造器查询，查询符合条件对象数量，条件构造器用法与前文相同 -List selectList( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询对象集合，，条件构造器用法与前文相同 -List&lt;Map&lt;String, Object&gt;&gt; selectMaps(Wrapper queryWrapper);&emsp;&emsp;该查询返回的是以map集合为对象的集合，不是对象的集合，用法一致123QueryWrapper &lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;);List&lt;Map&lt;String, Object&gt;&gt; maps = userDao.selectMaps(wrapper); -List selectObjs( Wrapper queryWrapper)&emsp;&emsp;查询对象集合 -IPage selectPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;分页查询，返回一个分页对象，包含该对象包含总条数、当前页数、每页显示条数、查询记录集合等参数12345678Page&lt;UserEntity&gt; page = new Page&lt;UserEntity&gt;(1,2);QueryWrapper&lt;UserEntity&gt; wrapper= new QueryWrapper&lt;&gt;();String username = &quot;田&quot;;String email = &quot;&quot;;wrapper.like(StringUtils.isNotEmpty(username),&quot;username&quot;,username) .like(StringUtils.isNotEmpty(email),&quot;email&quot;,email) .select(&quot;username&quot;,&quot;age&quot;);IPage &lt;UserEntity&gt; page1 = userDao.selectPage(page, wrapper); -IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;与上面方法用法一致，仅返回对象类型不同 7.自定义方法&emsp;&emsp;MP支持书写sql语句，即可以根据需求自定义方法，但是如果在自定义方法时希望用到条件构造器，MP也为我们提供了方法；12@Select(&quot;select * from t_user ${ew.customSqlSegment}&quot;) public List&lt;UserEntity&gt; getAll(@Param(Constants.WRAPPER) Wrapper&lt;UserEntity&gt; wrapper); &emsp;&emsp;使用上面的注解和标识即可在我们自定义方法中引入条件构造器了","link":"/2019/05/26/Mybatis Plus 基础使用手册/"},{"title":"","text":"数据库数据库特点1、降低存储数据的冗余度2、保持数据的一致性、完整性和安全性 数据库完整性可靠性+准确性=数据完整性 数据完整性的分类1、实体完整性 保证一行数据的有效性2、域完整性 保证一列数据是有效的3、应用完整性 保证引用的编号是有效的4、用户自定义完整性 保证自定义规则 数据完整性：实体完整性：不能出现两条一模一样的记录，实现有两个：主键约束、唯一约束。域完整性：保证指定列输入值得合法性，实现方式：非空约束、默认值、检查约束(check)。引用完整性：保证从表的外键，必须引用主表中主键出现的值，实现方式：外键约束 非空约束是指，如果该列的值不能为null值。默认值（DEFAULT）是指，如果该列的值不能做插入，那么以默认值填充该列的值。如果该列的值做了插入，那么以插入值为准。检查约束是指，规定改列的值得取值范围。 唯一约束（Unique）： 唯一约束是值给定列的所有值必须唯一，该列在表中每一行的值必须唯一，它和主键约束的区别在于该列可以为空，并且可以在一张表中给多个列设置唯一约束。 主键约束（Primary key）： 主键是表中的一到多个列，主键列不能为空，也不能重复，一个表中只能有一个主键。 外键约束（foreign key）：外键是指从表的某列与主表的某列存在依附关系。外键约束是指在外键关联主键上强制加上一个约束，如果违反该约束，则不允许该条数据的修改。 注意：没有建立外键约束不等于没有外键。– 添加外键约束– fk开始的约束表示外键约束，pk开始的约束表示主表约束– 外键只出现在从表中alter table t_car add constraint fk_1 foreign key(manId) references t_man(id);含义 ：更新表 t_car 添加约束 外键(manId) 引用 t_man(id) 数据模型在数据库的发展中，出现了许多数据模型，层次模型、网状模型、对象模型和关系模型。关系模型使用居多。 关系模型：把世界看做由实体（Entity）和联系（Relationship）组成，实体就是指在现实世界客观存在并可相互区别的事物，他可能是有形或者无形的、具体的或抽象的、有生命的或无生命的。 实体所具有的某一特性称为属性（Attribute）。实体可以通过若干属性来描述。 以关系型模型来创建的数据库称为关系型数据库。关系型数据库：以表作为实体，以表之间的主外键关系作为联系的数据库结构。 表（table）是关系型数据库的核心单元，是储存数据的地方。在表的内部，数据被分为列（column）和行（row）。填入表中的每一行，代表一个实体，也就是说表中的每一行代表真实世界的一个事物。行代表一个实体。列代表实体的属性，同时也限定了数据的类型。主键：在关系型数据库表中，用一个唯一的标识符来标识每一行的标识就是主键。外键：用来表达表与表之间的联系的标识。 RDBMS是管理、操作、维护关系型数据库的一种软件程序。 SQL是关系型数据库的标准编程语言，使用SQL语句访问和操纵数据库中的数据。 常见的关系 一对一: 在开发中,例如:person idcard 思路1:将两个实体合二为一。 思路2:在一个表上将这个表的主键设置成外键且添加外键约束。 一对多: 在开发中,在多表的一方添加一个外键,外键的名称一般为主表的名称_id,字段类型一般和主表的主键的类型保持一致。 为了保证数据的有效性和完整性,在多表的一方添加外键约束(不是必须的,也可以通过java程序来控制) 格式: alter table 多表名称 add foreign key(外键名称) references 主表名称(主键名称) 多对多: 在开发中,一般引入一个中间表,在中间表中存放另外两张表的主键.这样就可以将多对多的关系拆分两个一对多的关系。 为了保证数据的有效性和完整性,在中间表上添加两个外键约束(不是必须的,也可以通过java程序来控制) 外键约束的特点: 1.主表中不能删除从表中已引用的数据。 2.从表中不能添加主表中不存在的数据。 数据库语言：1、数据库定义语言（DDL）2、数据查询语言（DQL）3、数据操作语言（DML）4、数据库控制语言（DCL）5、事物控制语言（TCL） 数据库定义语言（DDL） create drop alter创建、修改、删除数据库的内部数据结构。 查看数据库 show databases选择要使用的数据库 use 数据库名查看你当前使用的数据库 select databases查看数据库使用的表 show tables查看另一个数据库 show tables from 数据库名创建数据库 create database 数据库的名称导入sql文件 source 文件路径查看表的数据结构 desc 表名 创建表：create table 表名( 字段名 约束 primary key (主键) auto_increment(自动增长列) …..); – 添加地址列alter table 表名 add 添加的列； –修改列ALTER TABLE 表名CHANGE 旧列 新列 ; –删除列ALTER TABLE 表名 DROP COLUMN 列名; 数据查询语言（DQL）用于数据库中的数据查询。关键词 select 语句的执行顺序： 1、form 将硬盘的表文件加载到内存 2、where 将符合条件的数据行摘取出来，生成一张新的临时表 3、group by 根据列中的数据种类，，将当前临时表划分成若干个新的临时表 4、having 可以过滤group by 生成的不符合条件的临时表 5、select 对当前临时表进行整列读取 6、order by 对select生成的临时表，进行重新排序，生成新的临时表 7、limit 对最终生成的临时表的数据行，进行截取where支持的运算符 having和where的区别：二者都是过滤条件，where运行在分组前，因此不能执行任何聚合函数。having是运行在分组后，只能用做聚合函数。 功能关键词：distinct 去除重复元素like 模糊查询 “_” 表示任何单个字符“%” 表示零个或多个任意字符 order by 排序。默认升序 或者使用asc(升序)、desc(降序)进行指定排序in(参数，参数，参数…..) 符合任意参数都可以。 group by 分组分组后再查询列中只能出现分组列和聚合函数。 MySQL的日期格式：1.日期是数据库本身的特色，也是数据库本身机制中的一个重要内容。 2.每个数据库处理日期是采用的机制都不一样，都有自己的一套处理机制，所以在实际开发中将日期定义为DATE类型的情况很少。 3.如果使用日期类型，java程序将不能通过。在实际开发中，一般会使用”日期字符串”创建日期。 数据操作语言（DML）用于数据库中数据的修改、包括添加、删除、修改等。 关键词：insert delete update添加数据：insert into 表名(字段名) values（字段值）; 修改语句：UPDATE 表名 SET 修改的内容 修改的条件； 删除表中的数据delete from 表名 [where 条件]; delete from 表名；truncate table 表名；二者的区别：delete 会记录日志，意味着删除后的数据还可以恢复，但是效率低。truncate table 不会记录日志，删除后数据不能恢复，但是效率高。 多分支判读语句：CASE WHEN 条件 THEN 返回值 WEEN 条件 THEN 返回值 ….. ELSE 返回值 END 数据库控制语言（DCL）控制数据库访问权限。 事物控制语言（TCL）各种事务的管理能力。关键词： commit rollback 事物是用户定义的一个操作序列。事物认为，这些操作序列是一个不可分割的工作单位，事物有四个特点：原子性，一致性，隔离性和持久性。 原子性：事务里面的操作单元不可切割,要么全部成功,要么全部失败一致性:事务执行前后,业务状态和其他业务状态保持一致.隔离性:一个事务执行的时候最好不要受到其他事务的影响持久性:一旦事务提交或者回滚.这个状态都要持久化到数据库中 实现事物的步骤：1、保证同一个业务方法中，所有的DAO使用同一个连接对象。2、将连接对象的提交方式设置为手动提交。然后，通过连接对象的commit()方法提交事物，通过连接对象的rollback()方法回滚事务。Connection的中的方法： setAutoCommit(false):手动开启事务 commit():事务提交 rollback():事务回滚 不考虑隔离性会出现的读问题 脏读:在一个事务中读取到另一个事务没有提交的数据 不可重复读:在一个事务中,两次查询的结果不一致(针对的update操作) 虚读(幻读):在一个事务中,两次查询的结果不一致(针对的insert操作) 通过设置数据库的隔离级别来避免上面的问题 read uncommitted 读未提交 上面的三个问题都会出现 read committed 读已提交 可以避免脏读的发生 repeatable read 可重复读 可以避免脏读和不可重复读的发生 serializable 串行化 可以避免所有的问题 聚合函数count：统计行数量count(*) 统计全部数据，count(列名) 空列不统计 sun：获取单个列的合计值avg：计算某个列的平均值– avg统计平均分也只统计非空列 max：计算列的最大值min:计算列的最小值 数据处理函数： 子查询如果子查询返回的值为单行单列，才能使用&gt;、=、!=、&lt;、&lt;=、&gt;=如果子查询返回的值为多行单列，只能使用in或not in 多表查询笛卡尔积现象 含义：若两张表进行连接查询的时候没有任何矫健限制，最终的查询结果总数是两张表记录的乘积，这就是笛卡尔积现象。2.跨表查询语句格式 内连接：只显示两个表中有对应记录的数据。 外连接： 定义： 可以显示一个表中所有的数据，无论该记录是否有关联 A表和B表能够完全匹配的记录查询出来之外，将其中一张表的记录无条件的查询出来，对方调用匹配的记录时，会自动模拟出null值与之匹配。 注意：外连接的查询结果条数》=内连接的查询结果条数 左外连接（左链接）： 定义：包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 Left：让左边表无条件全部显示 右外连接（右连接）： 定义：包含左边表的全部行（不管右边的表是否存在于它们匹配的行），以及右边表中全部匹配的行。 right：让右边表无条件全部显示 全连接： 定义：包含左右两个表的全部行，不管另一边的表中是否存在与之它们匹配的行。 如何删除主表记录：两个表建立了关联之后，当删除主表记录时，如果该主表记录有从表记录所关联，那么，由于有外键约束存在，则不允许删除。删除方法（视要求而定）：1、级联删除：先将主表记录对应的从表记录删除，然后再删除主表记录。2、外键置空：先将该主表记录对应的从表记录外键设置为null值，然后再删除主表记录。","link":"/2019/06/20/数据库/"}],"tags":[],"categories":[]}