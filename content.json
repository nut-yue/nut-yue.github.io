{"pages":[],"posts":[{"title":"","text":"前言&emsp;&emsp;mybatis plus(后简称MP)，是对mybatis的一个增强工具，使用MP不影响mybatis的基本使用，使用与JPA类似，目的为简化开发，提升效率。 一.安装&emsp;&emsp;使用spring boot 集成，只需要在pom.xml中加入MP的依赖包，需要注意的是，引入MP时不需要再引入mybatis，以免引起版本冲突123456&lt;!--引入mybatis plus 依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 二.配置&emsp;&emsp;MP提供了很多的配置选项，这里我们只配置基础配置，更多配置及进阶配置，可以查看官网手册&emsp;mybatis plus官网在springboot中，配置书写在application.properties中123456789&lt;!--配置数据源--&gt;spring.datasource.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=tt123456&lt;!--配置别名--&gt;mybatis-plus.type-aliases-package=com.lovo.entity&lt;!--配置sql语句控制台输出--&gt;mybatis-plus.configuration.log-impl= org.apache.ibatis.logging.stdout.StdOutImpl &emsp;&emsp;在MP中内置了分页插件，需要通过java类的方式进行配置，可以在工程下建一个config的包，再建一个MybatisPlusConfig配置文件,该文件直接复制即可，不做更改123456789101112@Configurationpublic class MybatisPlusConfig { /** * mybatis-plus分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor page = new PaginationInterceptor(); page.setDialectType(&quot;mysql&quot;); return page; }} 三.基础使用&emsp;&emsp;MP内置了基本的CRUD，条件查询，分页等操作，可以极大简化单表操作效率；&emsp;&emsp;首先，MP中提供了代码生成器功能，可以直接使用该工具生成mapper,controller,Entity,Service类，但生成的类仅有类名和一些继承关系，感觉用处不是很大，并且生成的诸如实体类，由于MP自己的映射关系，生成的字段不便于阅读，故建议不采用此功能&emsp;&emsp;然后，MP中提供了两类CRUD接口，一类是Mapper接口，一类是service接口，两者功能相似，service接口实则是对mapper接口方法的调用和封装，因此，本文只介绍mapper接口使用方法，service接口方法可自行查阅官网文档；&emsp;&emsp;Mapper接口方法的使用仅需要集成BaseMapper接口，就可以使用MP为我们提供的方法；1public interface UserMapper extends SqlMapper, BaseMapper&lt;UserEntity&gt; 1.常用注解12345678@TableName(&quot;t_user&quot;) // 用于表示实体类对应的数据库表名public class UserEntity @TableId // 主键标识private int id; @TableField(&quot;username&quot;) // 当属性名和数据库字段名不匹配时用于表示对应关系private String name; 2.条件构造器Warpper&emsp;&emsp;MP种支持单字段,List集合，Map集合，条件构造器作为条件的CRUD操作，其中前三者较为常见，而条件构造器接触较少，故单独做一介绍；条件构造器包含QueryWarpper和UpdateWarpper，两者功能基本一致，提供eq(等于)、ne(不等于)、gt(大于)、lt（小于）、like、notlike、in、ordreBy等大量的条件判断方法； -addEq:多个字段对应相等；12allEq(Map&lt;R, V&gt; params)allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt; 0,{id:1,name:&quot;老王&quot;,age:null})---&gt;name = &apos;老王&apos; and age is null -eq:相等；12eq(R column, Object val)eq(&quot;name&quot;, &quot;老王&quot;)---&gt;name = &apos;老王&apos; -ne:不相等；12ne(R column, Object val)ne(&quot;name&quot;, &quot;老王&quot;)---&gt;name &lt;&gt; &apos;老王&apos; -gt:大于；12gt(R column, Object val)gt(&quot;age&quot;, 18)---&gt;age &gt; 18 -ge:大于等于；12ge(R column, Object val)ge(&quot;age&quot;, 18)---&gt;age &gt;= 18 -lt:小于；12lt(R column, Object val)lt(&quot;age&quot;, 18)---&gt;age &lt; 18 -le:小于等于；12le(R column, Object val)le(&quot;age&quot;, 18)---&gt;age &lt;= 18 -between:BETWEEN 值1 AND 值2；12between(R column, Object val1, Object val2)between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30 -notBetween:NOT BETWEEN 值1 AND 值212notBetween(R column, Object val1, Object val2)notBetween(&quot;age&quot;, 18, 30)---&gt;age not between 18 and 30 -like:LIKE ‘%值%’12like(R column, Object val)like(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王%&apos; -notlike：NOT LIKE ‘%值%’12notLike(R column, Object val)notLike(&quot;name&quot;, &quot;王&quot;)---&gt;name not like &apos;%王%&apos; -likeLeft ：LIKE ‘%值’12likeLeft(R column, Object val)likeLeft(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王&apos; -likeRight:LIKE ‘值%’12likeRight(R column, Object val)likeRight(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;王%&apos; -isNull:字段 IS NULL12isNull(R column)isNull(boolean condition, R column) -isNotNull:字段 IS NOT NULL12isNotNull(R column)isNotNull(&quot;name&quot;)---&gt;name is not null -in:字段 IN (value.get(0), value.get(1), …)12in(R column, Collection&lt;?&gt; value)in(&quot;age&quot;,{1,2,3})---&gt;age in (1,2,3) -notIn:字段 notIn (value.get(0), value.get(1), …)12notIn(R column, Collection&lt;?&gt; value)notIn(&quot;age&quot;,{1,2,3})---&gt;age not in (1,2,3) -inSql:字段 IN ( sql语句 )12inSql(R column, String inValue)inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3) -notInSql:NOT IN ( sql语句 )12notInSql(R column, String inValue)notInSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;age not in (select id from table where id &lt; 3) -groupBy:GROUP BY 字段, …12groupBy(R... columns)groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name -orderByAsc:ORDER BY 字段, … ASC12orderByAsc(R... columns)orderByAsc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id ASC,name ASC -orderByDesc:ORDER BY 字段, … DESC12orderByDesc(R... columns)orderByDesc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id DESC,name DESC 注：上述条件方法均含有一个默认值为true的参数，表示该条件会拼接到SQL语句中，如传一个false,则该条件不会拼接到SQL中，在动态条件查询时，可以传入StringUtils.isNotEmpty(参数)来动态拼接sql语句；更多条件方法可上官网了解详情 -创建条件构造器1234&lt;!--直接new对象--&gt;QueryWrapper&lt;T&gt; wrapper = new QueryWrapper&lt;&gt;();&lt;!--使用Warppers工具类获得--&gt;QueryWrapper&lt;T&gt; wrapper = Warppers.&lt;T&gt;query(); -使用实例12345678&lt;!--查询姓张，年龄20-40岁之间且邮箱不为空的记录，查询字段不包括密码--&gt;QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;) .between(&quot;age&quot;,20,40) .isNotNull(&quot;email&quot;) .select(UserEntity.class,query-&gt;!query.getColumn().equals(&quot;password&quot;));List&lt;UserEntity&gt; users = userDao.selectList(wrapper);users.forEach(System.out::println); 3.添加- int insert(T entity)&emsp;&emsp;传入对象即可完成添加，返回操作条数 4.删除- int deleteById(Serializable id)&emsp;&emsp;通过id进行删除，返回操作条数 - int deleteByMap(Map&lt;String, Object&gt; columnMap)&emsp;&emsp;通过Map集合进行删除，返回操作条数，map集合为键为表的字段，值为字段所对应的值，后面所有Map用法相同，不做赘述；12345&lt;!--相当于delete from t_user where username=&apos;musi&apos; and age=26--&gt;Map &lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;username&quot;,&quot;musi&quot;);map.put(&quot;age&quot;,26);int result = userDao.deleteByMap(map); -int delete( Wrapper wrapper)&emsp;&emsp;通过条件构造器进行删除123QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.inSql(&quot;age&quot;,&quot;35,25&quot;);int result = userDao.delete(wrapper); -int deleteBatchIds( Collection&lt;? extends Serializable&gt; idList)&emsp;&emsp;通过id集合批量删除;12List&lt;Integer&gt; ids = Arrays.asList(13,12);int result = userDao.deleteBatchIds(ids); 5.修改-int updateById(T t)&emsp;&emsp;传入修改对象实例 -int update( T t,Wrapper updateWrapper);&emsp;&emsp;根据条件构造器修改123456UserEntity user = userDao.selectById(2);user.setName(&quot;田七&quot;);user.setAge(30);UpdateWrapper&lt;UserEntity&gt; update = new UpdateWrapper&lt;&gt;();update.eq(&quot;age&quot;,20).eq(&quot;username&quot;,&quot;赵六&quot;);int result= userDao.update(user,update); 6.查询- T selectById(Serializable id)&emsp;&emsp;根据id查询单个对象 -List selectBatchIds(Collection&lt;? extends Serializable&gt; idList);&emsp;&emsp;通过id集合查询对象集合 -List selectByMap(Map&lt;String, Object&gt; columnMap);&emsp;&emsp;根据map集合查询对象集合，用法与前文map集合用法相同 -UserEntity selectOne( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询单个对象，用法与前文条件构造器用法相同 - Integer selectCount(Wrapper queryWrapper);&emsp;&emsp;条件构造器查询，查询符合条件对象数量，条件构造器用法与前文相同 -List selectList( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询对象集合，，条件构造器用法与前文相同 -List&lt;Map&lt;String, Object&gt;&gt; selectMaps(Wrapper queryWrapper);&emsp;&emsp;该查询返回的是以map集合为对象的集合，不是对象的集合，用法一致123QueryWrapper &lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;);List&lt;Map&lt;String, Object&gt;&gt; maps = userDao.selectMaps(wrapper); -List selectObjs( Wrapper queryWrapper)&emsp;&emsp;查询对象集合 -IPage selectPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;分页查询，返回一个分页对象，包含该对象包含总条数、当前页数、每页显示条数、查询记录集合等参数12345678Page&lt;UserEntity&gt; page = new Page&lt;UserEntity&gt;(1,2);QueryWrapper&lt;UserEntity&gt; wrapper= new QueryWrapper&lt;&gt;();String username = &quot;田&quot;;String email = &quot;&quot;;wrapper.like(StringUtils.isNotEmpty(username),&quot;username&quot;,username) .like(StringUtils.isNotEmpty(email),&quot;email&quot;,email) .select(&quot;username&quot;,&quot;age&quot;);IPage &lt;UserEntity&gt; page1 = userDao.selectPage(page, wrapper); -IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;与上面方法用法一致，仅返回对象类型不同 7.自定义方法&emsp;&emsp;MP支持书写sql语句，即可以根据需求自定义方法，但是如果在自定义方法时希望用到条件构造器，MP也为我们提供了方法；12@Select(&quot;select * from t_user ${ew.customSqlSegment}&quot;) public List&lt;UserEntity&gt; getAll(@Param(Constants.WRAPPER) Wrapper&lt;UserEntity&gt; wrapper); &emsp;&emsp;使用上面的注解和标识即可在我们自定义方法中引入条件构造器了","link":"/2019/05/26/Mybatis Plus 基础使用手册/"}],"tags":[],"categories":[]}