{"pages":[],"posts":[{"title":"为什么程序员都应该使用MarkDown","text":"一.MrakDown简介&emsp;&emsp;Mrakdown：一种轻量级标记语言，语法简洁明了，易于掌握，易读易写。MrakDown如今被程序员广泛使用，适用于写博客日志、技术文稿、记录代码片段、起草邮件等场景。 &emsp;Mrakdown的优点： 可以使我专注于文字的内容，而非排版样式 能够轻松的导出HTML、PDF以及.md文件 纯文本内容，兼容所有的文本编辑器与字处理软件 可读、直观、学习成本低&emsp;Markdown的缺点： 格式单一，不支持类似于word一样的负责的格式 对图片等其他资源的排版不具备个性化处理功能二.MarkDown常用语法1.标题markdown中共包含6级标题,字体大小递减123456# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题 2.标题字体样式12345*内容* 斜体**内容** 加粗***内容*** 斜体加粗~~内容~~ 删除线&lt;font face=&quot;宋体&quot; color:&quot;black&quot; size=&quot;6&quot;&gt;字体大小样式和颜色&lt;/font&gt; 3.列表3.1 无序列表无序列表使用-、+和*作为列表标记12345678- 条目1- 条目2+ 条目1+ 条目2* 条目1* 条目2 3.2 有序列表有序列表使用数字加英文句点表示； 4.引用123&gt; 一级引用&gt;&gt; 二级引用&gt;&gt;&gt; 三级引用 5.字体上下标12&lt;sup&gt;这是上标&lt;/sup&gt;&lt;sub&gt;这是下标&lt;/sub&gt; 6.图片和链接&emsp;&emsp;图片和链接的语法很像，区别在一个！号，需要注意的是，markdown不能设置图片的大小，如果要设置，则使用标签.12图片：！[图片描述（可忽略）](链接的地址)链接：[链接描述]（链接的地址） 链接分为行内式、参考式和自动链接1234行内式：[链接文本]（http://www.google.com）参考式：[链接文本][url],其中url为链接标记，可置于文本中任意位置 [url]:www.google.com自动链接：&lt;www.google.com&gt; 7.代码块1&lt;h4&gt;以```开始和结尾，中间可以书写任意格式的代码&lt;/h4&gt; 8.表格123|姓名|年龄|班级||:---|:---|:---||左对齐|居中对齐|右对齐| 示例：|姓名|年龄|班级||:—|:—|:—||左对齐|居中对齐|右对齐| 9.分割线12345***---————* * *上述四种写法均表示分割线 10.脚注|注解10.1使用[^]来定义脚注：12示例：[^1][^1]:脚注 10.2注释注释仅自己可见，无预览效果1&lt;!--注释--&gt;","link":"/2019/04/03/MarkDown/"},{"title":"浅谈sql优化","text":"&emsp;&emsp;数据库查询效率的快慢是评价一个数据库设计好坏的直接判定依据，一个设计良好的数据库系统，受到多方面的因素影响，例如硬件配置、网络状况等。对于程序设计人员，提高数据库查询效率最有效的最简单的方式便是优化sql语句；&emsp;&emsp;造成数据库查询缓慢的常见原因：&emsp;&emsp;&emsp;&emsp;1.查询数据的数据量庞大；&emsp;&emsp;&emsp;&emsp;2.数据库设计不合理；&emsp;&emsp;&emsp;&emsp;3.sql语句书写不佳；&emsp;&emsp;&emsp;&emsp;4.硬件性能、网络状况；&emsp;&emsp;&emsp;&emsp;……&emsp;&emsp;正是由于上述存在的问题，优化数据库应该从数据库设计、sql语句书写入手，从源头进行优化，尽量避免进行全表扫描，正确合理的使用索引，本系列文章将和大家共同探讨sql的优化； 一.了解数据库表&emsp;1.巧用explain:explain命令可以查看sql的执行计划，执行状态，例如是否使用索引，是否全表查询，也可以使用explain查看数据表的设计详情；&emsp;2.在select前加上explain命令可以显示数据库执行的具体情况二.巧用索引&emsp;&emsp;要想让一个查询语句执行效率更快。首要的，需要考虑能否添加索引。索引是一个特殊的文件，包含着对数据库表中所有记录的指针，它是对数据库表中一列或者多列的值进行排序的一种结构。&emsp;&emsp;索引好比是图书馆里，每一本书上的编号，借阅者可以通过图书馆的馆藏搜索系统，快速的查找到对应的书籍的所在位置，大大减少了寻找的时间，提供搜索效率；&emsp;&emsp;索引的优点:&emsp;&emsp;&emsp;&emsp;1.通过添加唯一索引，可以保证数据唯一性；&emsp;&emsp;&emsp;&emsp;2.可以大大提高数据的检索速度；&emsp;&emsp;&emsp;&emsp;3.可以加速表和表之间的连接；&emsp;&emsp;索引大体可以分为：普通索引、唯一索引、主键索引、全文索引12345678910普通索引分为单列索引和多列索引：1.单列索引：一个索引只包含单个列，但是一个表中可以包含多个单列索引；2.多列索引：一个索引包含多个索引；创建普通索引：- create index 索引名 on 表名（列名）- alter table 表名 add unique index 索引名（列名）- create table 表名 （ 列名 数据类型 约束， unique index 索引名（列名） ）","link":"/2019/04/08/浅谈sql优化/"},{"title":"","text":"前言&emsp;&emsp;mybatis plus(后简称MP)，是对mybatis的一个增强工具，使用MP不影响mybatis的基本使用，使用与JPA类似，目的为简化开发，提升效率。 一.安装&emsp;&emsp;使用spring boot 集成，只需要在pom.xml中加入MP的依赖包，需要注意的是，引入MP时不需要再引入mybatis，以免引起版本冲突123456&lt;!--引入mybatis plus 依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt;&lt;/dependency&gt; 二.配置&emsp;&emsp;MP提供了很多的配置选项，这里我们只配置基础配置，更多配置及进阶配置，可以查看官网手册&emsp;mybatis plus官网在springboot中，配置书写在application.properties中123456789&lt;!--配置数据源--&gt;spring.datasource.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.username=rootspring.datasource.password=tt123456&lt;!--配置别名--&gt;mybatis-plus.type-aliases-package=com.lovo.entity&lt;!--配置sql语句控制台输出--&gt;mybatis-plus.configuration.log-impl= org.apache.ibatis.logging.stdout.StdOutImpl &emsp;&emsp;在MP中内置了分页插件，需要通过java类的方式进行配置，可以在工程下建一个config的包，再建一个MybatisPlusConfig配置文件,该文件直接复制即可，不做更改123456789101112@Configurationpublic class MybatisPlusConfig { /** * mybatis-plus分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() { PaginationInterceptor page = new PaginationInterceptor(); page.setDialectType(&quot;mysql&quot;); return page; }} 三.基础使用&emsp;&emsp;MP内置了基本的CRUD，条件查询，分页等操作，可以极大简化单表操作效率；&emsp;&emsp;首先，MP中提供了代码生成器功能，可以直接使用该工具生成mapper,controller,Entity,Service类，但生成的类仅有类名和一些继承关系，感觉用处不是很大，并且生成的诸如实体类，由于MP自己的映射关系，生成的字段不便于阅读，故建议不采用此功能&emsp;&emsp;然后，MP中提供了两类CRUD接口，一类是Mapper接口，一类是service接口，两者功能相似，service接口实则是对mapper接口方法的调用和封装，因此，本文只介绍mapper接口使用方法，service接口方法可自行查阅官网文档；&emsp;&emsp;Mapper接口方法的使用仅需要集成BaseMapper接口，就可以使用MP为我们提供的方法；1public interface UserMapper extends SqlMapper, BaseMapper&lt;UserEntity&gt; 1.常用注解12345678@TableName(&quot;t_user&quot;) // 用于表示实体类对应的数据库表名public class UserEntity @TableId // 主键标识private int id; @TableField(&quot;username&quot;) // 当属性名和数据库字段名不匹配时用于表示对应关系private String name; 2.条件构造器Warpper&emsp;&emsp;MP种支持单字段,List集合，Map集合，条件构造器作为条件的CRUD操作，其中前三者较为常见，而条件构造器接触较少，故单独做一介绍；条件构造器包含QueryWarpper和UpdateWarpper，两者功能基本一致，提供eq(等于)、ne(不等于)、gt(大于)、lt（小于）、like、notlike、in、ordreBy等大量的条件判断方法； -addEq:多个字段对应相等；12allEq(Map&lt;R, V&gt; params)allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt; 0,{id:1,name:&quot;老王&quot;,age:null})---&gt;name = &apos;老王&apos; and age is null -eq:相等；12eq(R column, Object val)eq(&quot;name&quot;, &quot;老王&quot;)---&gt;name = &apos;老王&apos; -ne:不相等；12ne(R column, Object val)ne(&quot;name&quot;, &quot;老王&quot;)---&gt;name &lt;&gt; &apos;老王&apos; -gt:大于；12gt(R column, Object val)gt(&quot;age&quot;, 18)---&gt;age &gt; 18 -ge:大于等于；12ge(R column, Object val)ge(&quot;age&quot;, 18)---&gt;age &gt;= 18 -lt:小于；12lt(R column, Object val)lt(&quot;age&quot;, 18)---&gt;age &lt; 18 -le:小于等于；12le(R column, Object val)le(&quot;age&quot;, 18)---&gt;age &lt;= 18 -between:BETWEEN 值1 AND 值2；12between(R column, Object val1, Object val2)between(&quot;age&quot;, 18, 30)---&gt;age between 18 and 30 -notBetween:NOT BETWEEN 值1 AND 值212notBetween(R column, Object val1, Object val2)notBetween(&quot;age&quot;, 18, 30)---&gt;age not between 18 and 30 -like:LIKE ‘%值%’12like(R column, Object val)like(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王%&apos; -notlike：NOT LIKE ‘%值%’12notLike(R column, Object val)notLike(&quot;name&quot;, &quot;王&quot;)---&gt;name not like &apos;%王%&apos; -likeLeft ：LIKE ‘%值’12likeLeft(R column, Object val)likeLeft(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;%王&apos; -likeRight:LIKE ‘值%’12likeRight(R column, Object val)likeRight(&quot;name&quot;, &quot;王&quot;)---&gt;name like &apos;王%&apos; -isNull:字段 IS NULL12isNull(R column)isNull(boolean condition, R column) -isNotNull:字段 IS NOT NULL12isNotNull(R column)isNotNull(&quot;name&quot;)---&gt;name is not null -in:字段 IN (value.get(0), value.get(1), …)12in(R column, Collection&lt;?&gt; value)in(&quot;age&quot;,{1,2,3})---&gt;age in (1,2,3) -notIn:字段 notIn (value.get(0), value.get(1), …)12notIn(R column, Collection&lt;?&gt; value)notIn(&quot;age&quot;,{1,2,3})---&gt;age not in (1,2,3) -inSql:字段 IN ( sql语句 )12inSql(R column, String inValue)inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;id in (select id from table where id &lt; 3) -notInSql:NOT IN ( sql语句 )12notInSql(R column, String inValue)notInSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)---&gt;age not in (select id from table where id &lt; 3) -groupBy:GROUP BY 字段, …12groupBy(R... columns)groupBy(&quot;id&quot;, &quot;name&quot;)---&gt;group by id,name -orderByAsc:ORDER BY 字段, … ASC12orderByAsc(R... columns)orderByAsc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id ASC,name ASC -orderByDesc:ORDER BY 字段, … DESC12orderByDesc(R... columns)orderByDesc(&quot;id&quot;, &quot;name&quot;)---&gt;order by id DESC,name DESC 注：上述条件方法均含有一个默认值为true的参数，表示该条件会拼接到SQL语句中，如传一个false,则该条件不会拼接到SQL中，在动态条件查询时，可以传入StringUtils.isNotEmpty(参数)来动态拼接sql语句；更多条件方法可上官网了解详情 -创建条件构造器1234&lt;!--直接new对象--&gt;QueryWrapper&lt;T&gt; wrapper = new QueryWrapper&lt;&gt;();&lt;!--使用Warppers工具类获得--&gt;QueryWrapper&lt;T&gt; wrapper = Warppers.&lt;T&gt;query(); -使用实例12345678&lt;!--查询姓张，年龄20-40岁之间且邮箱不为空的记录，查询字段不包括密码--&gt;QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;) .between(&quot;age&quot;,20,40) .isNotNull(&quot;email&quot;) .select(UserEntity.class,query-&gt;!query.getColumn().equals(&quot;password&quot;));List&lt;UserEntity&gt; users = userDao.selectList(wrapper);users.forEach(System.out::println); 3.添加- int insert(T entity)&emsp;&emsp;传入对象即可完成添加，返回操作条数 4.删除- int deleteById(Serializable id)&emsp;&emsp;通过id进行删除，返回操作条数 - int deleteByMap(Map&lt;String, Object&gt; columnMap)&emsp;&emsp;通过Map集合进行删除，返回操作条数，map集合为键为表的字段，值为字段所对应的值，后面所有Map用法相同，不做赘述；12345&lt;!--相当于delete from t_user where username=&apos;musi&apos; and age=26--&gt;Map &lt;String,Object&gt; map = new HashMap&lt;&gt;();map.put(&quot;username&quot;,&quot;musi&quot;);map.put(&quot;age&quot;,26);int result = userDao.deleteByMap(map); -int delete( Wrapper wrapper)&emsp;&emsp;通过条件构造器进行删除123QueryWrapper&lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.inSql(&quot;age&quot;,&quot;35,25&quot;);int result = userDao.delete(wrapper); -int deleteBatchIds( Collection&lt;? extends Serializable&gt; idList)&emsp;&emsp;通过id集合批量删除;12List&lt;Integer&gt; ids = Arrays.asList(13,12);int result = userDao.deleteBatchIds(ids); 5.修改-int updateById(T t)&emsp;&emsp;传入修改对象实例 -int update( T t,Wrapper updateWrapper);&emsp;&emsp;根据条件构造器修改123456UserEntity user = userDao.selectById(2);user.setName(&quot;田七&quot;);user.setAge(30);UpdateWrapper&lt;UserEntity&gt; update = new UpdateWrapper&lt;&gt;();update.eq(&quot;age&quot;,20).eq(&quot;username&quot;,&quot;赵六&quot;);int result= userDao.update(user,update); 6.查询- T selectById(Serializable id)&emsp;&emsp;根据id查询单个对象 -List selectBatchIds(Collection&lt;? extends Serializable&gt; idList);&emsp;&emsp;通过id集合查询对象集合 -List selectByMap(Map&lt;String, Object&gt; columnMap);&emsp;&emsp;根据map集合查询对象集合，用法与前文map集合用法相同 -UserEntity selectOne( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询单个对象，用法与前文条件构造器用法相同 - Integer selectCount(Wrapper queryWrapper);&emsp;&emsp;条件构造器查询，查询符合条件对象数量，条件构造器用法与前文相同 -List selectList( Wrapper queryWrapper)&emsp;&emsp;条件构造器查询，查询对象集合，，条件构造器用法与前文相同 -List&lt;Map&lt;String, Object&gt;&gt; selectMaps(Wrapper queryWrapper);&emsp;&emsp;该查询返回的是以map集合为对象的集合，不是对象的集合，用法一致123QueryWrapper &lt;UserEntity&gt; wrapper = new QueryWrapper&lt;&gt;();wrapper.likeRight(&quot;username&quot;,&quot;张&quot;);List&lt;Map&lt;String, Object&gt;&gt; maps = userDao.selectMaps(wrapper); -List selectObjs( Wrapper queryWrapper)&emsp;&emsp;查询对象集合 -IPage selectPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;分页查询，返回一个分页对象，包含该对象包含总条数、当前页数、每页显示条数、查询记录集合等参数12345678Page&lt;UserEntity&gt; page = new Page&lt;UserEntity&gt;(1,2);QueryWrapper&lt;UserEntity&gt; wrapper= new QueryWrapper&lt;&gt;();String username = &quot;田&quot;;String email = &quot;&quot;;wrapper.like(StringUtils.isNotEmpty(username),&quot;username&quot;,username) .like(StringUtils.isNotEmpty(email),&quot;email&quot;,email) .select(&quot;username&quot;,&quot;age&quot;);IPage &lt;UserEntity&gt; page1 = userDao.selectPage(page, wrapper); -IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage page, Wrapper queryWrapper)&emsp;&emsp;与上面方法用法一致，仅返回对象类型不同 7.自定义方法&emsp;&emsp;MP支持书写sql语句，即可以根据需求自定义方法，但是如果在自定义方法时希望用到条件构造器，MP也为我们提供了方法；12@Select(&quot;select * from t_user ${ew.customSqlSegment}&quot;) public List&lt;UserEntity&gt; getAll(@Param(Constants.WRAPPER) Wrapper&lt;UserEntity&gt; wrapper); &emsp;&emsp;使用上面的注解和标识即可在我们自定义方法中引入条件构造器了","link":"/2019/05/26/Mybatis Plus 基础使用手册/"}],"tags":[],"categories":[]}